# Composable

There are a number of general functions that have been pulled out for reuse. These are available in the `composable` folder.

## Can
Provides functions to determine if the current user has permission to access certain parts of the system. Note that this is purely to enforce UI limitations. Data query limitations should also be limited permission verification steps on the backend.

This currently operates by calling a corresponding Vuex getter.

Example Usage:

```vue
<template>
  <!-- User has this specific permission -->
  <div v-if="can('This.Permission')">
    ...
  </div>

  <!-- User has any of these permissions -->
  <div v-if="canAny(['This.Permission', 'That.Permission'])">
    ...
  </div>

  <!-- User has all of these permissions -->
  <div v-if="canAll(['This.Permission', 'That.Permission'])">
    ...
  </div>
</template>

<script>
export default defineComponent({
  setup() {
    const {can, canAny, canAll} = useCan();

    return {can, canAny, canAll}
  }
})
</script>
```

## Charts

## Currency

Provides a helper function for formatting currency values a AUD.

Example usage:

```ts
const someAmountOfMoney = 1234;

const formatted = fmtCurrency(someAmountOfMoney);
console.log(formatted)
// > $1,234;
```

## Date

Various helper functions for handling and formatting dates

## Enum

Helper functions for transforming TypeScript enumerations (e.g. as generated by Service Proxies).

Example usage:

```vue
<template>
  <select>
    <option
      v-for="option in options"
      :key="option.value"
      :value="option.value"
    >
      {{ option.key }}
    </option>
  </select>
</template>

<script>
export default defineComponent({
  setup() {
    enum SomeEnum {
      SomeValue = 1,
      AnotherValue = 2,
    }

    const {toDescription, toDropdownOptions} = useEnum(SomeEnum);

    console.log(toDescription(SomeEnum.SomeValue))
    // > Some Value

    const options = toDropdownOptions();

    return {options}
  }
})
</script>
```

## InfiniteList

This provides helper functions for managing infinite list scenarios.

### useInfiniteListable

`useInfiniteListable` wraps some basic management capabilities for handling infinite list queries. It defers all queries to the Vuex store, as defined by the `ResourceInfiniteVuex` helper function.

```ts
const { items, loading, fetch, reset } = useInfiniteListable({
  items: MatterStore.getters.GET_MATTERS,
  query: MatterStore.actions.GET_MATTERS,
  queryParams: () => ({
    search: props.search,
  })
});
```

In essence, for the configuration:

- `items` defines the `getter` for accessing the list of items
- `query` defines the `action` for requesting a set of items
- `queryParmas` defines the additional parameters that should be passed to the `query` action. By default this will set and override any `limit` and `offset` values.
- `limit` defines the maximum number of items that should be retrieved per query. By default this is 50.

For the returned items:

- `items` is the set of items that have been requested
- `loading` indicates if the latest request is loading
- `fetch` is a function that can be called to fetch the next set of results
- `reset` is a function that be called to reset the query to start from the "beginning" of the list. Typically this is used to reset the results when a search query has been updated.

The `reset` function is typically used like so:

```ts
watch([() => props.search], reset);
```

### useInfiniteTrigger

`useInfiniteTrigger` wraps the handling of automatically calling a provided function (e.g. the `fetch` function or equivalent) when the container has been scrolled to the end.

This requires references to a containing DOM element, and a "sentinel" DOM element that is used as an indication of scroll location.

Example usage:

```vue
<template>
  <div ref="container">
    <div v-for="item in items" :key="item.id">
      {{item.value}}
    </div>
    <div ref="sentinel">
  </div>
</template>

<script>
export default defineComponent({
  props: {
    search: String
  },
  setup(){
    const { items, loading, fetch, reset } = useInfiniteListable({
      ...
    });

    watch([() => props.search], reset);

    const {container, sentinel} = useInfiniteTrigger(fetch);

    return {items, container, sentinel}
  }
})
</script>
```

::: tip
You may need to adjust the CSS to allow for overflow in order for scrolling to occur and for scroll events to be triggered/handled.
:::

You may choose to use this helper directly as with the above example or by using the `AlpInfiniteTable` or `AlpInfiniteContainer` components which use this under the hood.

## Listable

This is a minor wrapper around getters and actions for retrieving data in the `PaginatedDTO` format. See the code for an indication of what this does.

## ListableRelationships

## Logger

These are minor wrappers around the standard console logging functions. The intent of these is to prevent logs from being shown in a production scenario.

## Notify

This provides wrapping functions for firing off common dialogs/toast notifications. 

Example usage:

```ts
const {fireConfirm, fireSuccessToast, fireErrorToast} = useNotify()

fireConfirm("Some confirmaion message");
// Displays a pop up dialog for the user to confirm. This currently uses Sweetalert2

fireSuccessToast("Some success message");
// Triggers the display of a successful toast message

fireErrorToast("Some error message");
// Triggers the display of an error toast message
```

## Pagination

Manages the pagination state for the case of manual page based pagination.

::: tip
Given the migration to the "infinite list" approach to pagination, this is largely obsolete. This remains for any tables that have not been migrated over / potential future use.
:::

Given the following configuration options:

- `pageSize` defines the size of each page, i.e. the number of items on the page
- `total` defines the total number of results for the overall query
- `currentPage` defines the "current" page, that is the starting point for the pagination logic

This returns the following:

- `pageSize` the size of the page
- `total` the total number of results
- `currentPage` the current page
- `offset` the offset, i.e. the number of items to skip for the query to retrieve the "current" page
- `lastPage` the final page, i.e. the final page number
- `next` a function for moving the state to the "next" page
- `prev` a function for moving the state to the "previous" page
- `first` a function for moving the state back to the first page
- `last` a function for moving the state to the last page
- `set` a function for moving the state to a specific page

Example usage:

```ts
const {
  pageSize,
  total,
  currentPage,
  offset,
  lastPage,
  next,
  prev,
  first,
  last,
  set
} = usePagination({
  currentPage: 1,
  pageSize: 20,
  total: 60
});

next()
// currentPage == 2

prev()
// currentPage == 1

first()
// currentPage == 1

last()
// currentPage == 3

set(2)
// currentPage == 2
```

## Patchable

This is a helper function for managing the patching of data when a change is made to it.

It accepts two approaches to providing the base data from which changes are made:

- A set of getters and queries (actions) to use to retrieve this information
  - `identifier`. The identifier for retrieving the item from a store defined in a manner similar to `ResourceDictVuex`, i.e. the getter returns a function that accepts a key to retrieve the item from a map
  - `getter`. The getter that is to be used to retrieve the data
  - `query`. The action that is to be used to query for the data.
  - `queryParmas`. A function returning a set of parameters to be passed to the `query` to retrieve the data
- An existing `Ref` to the data

It also accepts a set of parameters defining the Vuex store action that should be called when a state change has been detected:

- `patchQuery` defines the action that should be called
- `patchQueryParams` defines a function that provides the parameters that should be passed to the query
- `callback` defines optional function that can be called after the patch query has been made

This returns a reactive `state` that is watched by the `usePatchable`.

The `patchQuery` is called with an object containing at least the following:

- `original` The original state prior to it being changed
- `updated` The updated state

Additional parameters are included as provided by `patchQueryParams`

## Popper

This provides a wrapper for handling the configuration of a simple Popper based dismissable dialog. This uses [Popper](https://popper.js.org/).

Given a:

- `selector` i.e. the DOM element that the popover should be anchored from
- `descriptor` i.e. the DOM element that should appear as the popover
- `options` a configuration object that defines the options for the popper element. Options are identical to those documented [here](https://popper.js.org/docs/v2/constructors/)
- `onClose` the function to be called when an "outside" click is detected, i.e. a click that does not fall within the `selector` or `descriptor` elements.

The function will handle the set up of the popper elements, and return a `forceUpdate` function. This function simply prompts popper to update it's positioning. This is not handled correctly otherwise in some cases, likely due to Vue redrawing the DOM from its virtual DOM.

Example usage:

```vue
<template>
  <span
    ref="selector"
    @click.stop="toggle"
  >
    Anchor
  </span>
  <span
    ref="descriptor"
    v-show="state.showDescriptor"
  >
    Content
  </span>
</template>

<script>
export default defineComponent({
  setup() {
    const state = reactive({
      showDescriptor: false
    })

    const selector = ref<HTMLElement | null>(null);
    const descriptor = ref<HTMLElement | null>(null);

    const { forceUpdate } = usePopper({
      selector,
      descriptor,
      options: {
        placement: "bottom-end",
        modifiers: [{ name: "hide" }]
      },
      onClose: () => (state.showOptions = false)
    });

    function toggle() {
      state.showDescriptor = !state.showDescriptor;
      forceUpdate();
    }

    return {state, toggle}
  }
})
</script>
```

## Preview

This provides helper functions related previewing a document:

- `canPreview` simply returns true if the provided content type or file extension is supported in terms preview ability
- `toExtension` converts the provided content type or extension to a file extension where possible.